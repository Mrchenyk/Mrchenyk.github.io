import{_ as e,n as r,a2 as t,m as o}from"./chunks/framework.DLL39-MI.js";const u=JSON.parse('{"title":"消息队列","description":"","frontmatter":{},"headers":[],"relativePath":"Notes/Learning/消息队列.md","filePath":"Notes/Learning/消息队列.md","lastUpdated":null}'),i={name:"Notes/Learning/消息队列.md"};function l(n,a,s,p,d,c){return o(),r("div",null,a[0]||(a[0]=[t('<h1 id="消息队列" tabindex="-1">消息队列 <a class="header-anchor" href="#消息队列" aria-label="Permalink to &quot;消息队列&quot;">​</a></h1><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h2><p>消息队列就像是一条高速公路上的排队系统，它使得各个系统组件之间能够松散耦合、异步处理任务，并且在面对高并发时能够保证系统的稳定运行。</p><h3 id="_1-什么是消息队列" tabindex="-1">1. 什么是消息队列？ <a class="header-anchor" href="#_1-什么是消息队列" aria-label="Permalink to &quot;1. 什么是消息队列？&quot;">​</a></h3><ul><li><strong>排队系统的比喻：</strong> 想象一下你去快餐店点餐。你下单后，订单就排在队里等待处理，厨房会按照先来的先做。这里的“订单”就类似于消息，而“队列”则确保所有订单按顺序被处理。这样即使同时有很多订单进来，厨房也能一个一个地完成，而不会手忙脚乱。</li><li><strong>松耦合（Decoupling）的好处：</strong> 在计算机系统中，不同的模块（比如用户请求处理、数据记录、邮件发送等）有时需要互相通信。使用消息队列，可以让一个模块把任务放入队列，然后其他模块再从队列中取出任务来处理。这样各个模块之间就不需要直接依赖，即使其中一个模块暂时忙不过来，任务也不会丢失，而是“排队”等待。</li></ul><h3 id="_2-消息队列的主要用途" tabindex="-1">2. 消息队列的主要用途 <a class="header-anchor" href="#_2-消息队列的主要用途" aria-label="Permalink to &quot;2. 消息队列的主要用途&quot;">​</a></h3><ul><li><strong>异步处理：</strong> 当你在网站上提交一个操作（例如上传图片、下订单等），系统可以立即响应用户，而把一些耗时的操作（比如图片处理、发送确认邮件）放到消息队列中，由后台慢慢处理。这样用户体验会更好，因为响应不会因为后台任务而变慢。</li><li><strong>流量削峰：</strong> 在一些访问量很大的系统中，瞬时请求量可能非常高。通过将这些请求先放入消息队列，再由后端系统逐步处理，可以有效防止系统因突然的大流量而崩溃，就像是排队等候可以防止拥堵一样。</li><li><strong>解耦系统模块：</strong> 各个模块之间通过消息队列来通信，彼此之间不直接调用。这样一来，如果某个模块需要升级或者暂时出现故障，其他模块仍然可以正常运行，因为消息会一直保存在队列中，等模块恢复后再处理。</li></ul><h3 id="_3-举个实际例子" tabindex="-1">3. 举个实际例子 <a class="header-anchor" href="#_3-举个实际例子" aria-label="Permalink to &quot;3. 举个实际例子&quot;">​</a></h3><p>假设你在一个电商平台上购物，下单后系统会：</p><ul><li>立即确认订单给你反馈，告诉你“订单已提交”。</li><li>同时，将订单信息放入消息队列。</li><li>后台的订单处理系统会从队列中依次取出订单，进行库存检查、支付处理、物流安排等操作。</li></ul><p>这样设计的好处是：</p><ul><li>用户不需要等所有操作都完成才看到结果。</li><li>各个处理环节可以独立扩展，比如遇到高峰期时，可以增加更多的订单处理服务来从队列中取单。</li></ul><h2 id="kafka" tabindex="-1">Kafka <a class="header-anchor" href="#kafka" aria-label="Permalink to &quot;Kafka&quot;">​</a></h2><p>Kafka 是一个高吞吐量、分布式的消息队列系统，主要用于构建实时数据流管道和流处理应用。它的核心概念包括“Producer（生产者）”、“Consumer（消费者）”、“Topic（主题）”以及“Broker（服务器节点）”。使用 Kafka，可以将数据流从一个系统传递到另一个系统，实现解耦和异步处理。</p><p>创建集群-&gt;新增Topic-&gt;编写生产者逻辑-&gt;编写消费者逻辑</p><h3 id="关键术语" tabindex="-1">关键术语 <a class="header-anchor" href="#关键术语" aria-label="Permalink to &quot;关键术语&quot;">​</a></h3><p>**Topic:**Kakfa中的逻辑队列，可以理解成每一个不同的业务场景就是一个不同的topic，对于这个业务来说，所有的数据都存储在这个topic中</p><p><strong>Cluster:</strong> Kafka的物理集群，每个集群中可以新建多个不同的topic</p><p><strong>Producer:</strong> 顾名思义，也就是消息的生产端，负责将业务消息发送到Topic当中</p><p><strong>Consumer:</strong> 消息的消费端，负责消费已经发送到topic中的消息</p><p>**Offset：**对于每一个Partition来说，每一条消息都有一个唯一的0ffset，消息在partition内的相对位置信息，并且严格递增</p><p><strong>Repica:</strong> 分片的副本，分布在不同的机器上，可用来容灾，Leader对外服务，Folower异步去拉取leader的数据进行一个同步，如果leader挂掉了，可以将Follower提升成leader，再对外进行服务。</p><p>**ISR: **意思是同步中的副本，对于Folower来说，始终和leader是有一定差距的，但当这个差距比较小的时候，我们就可以将这个folower副本加入到ISR中，不在ISR中的副本是不允许提升为Leader的。</p><p><strong>Partition:</strong> 通常topic会有多个分片，不同分片直接消息是可以并发来处理的，这样提高单个Topic的吞吐。对于每一个Partition来说，每一条消息都有一个唯一的Offset，消息在partition内的相对位置信息，并且严格递增。</p><h3 id="kafka保证快速、稳定的做法" tabindex="-1">Kafka保证快速、稳定的做法 <a class="header-anchor" href="#kafka保证快速、稳定的做法" aria-label="Permalink to &quot;Kafka保证快速、稳定的做法&quot;">​</a></h3><p>1、Producer：批量发送、数据压缩</p><p>2、Broker：顺序写，零拷贝、消息索引</p><p>3、Consumer：Rebalance</p>',28)]))}const f=e(i,[["render",l]]);export{u as __pageData,f as default};
